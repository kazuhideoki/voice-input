# ショートカットキーモード設計案

## 概要

現在のCLIベースのコマンド制御から、StackingModeをより効率的に操作するためのショートカットキー制御機能を追加する設計案。

## 現状の課題分析

### 現在のコマンド構造

StackingModeでは以下のコマンドが頻繁に使用される：

1. `voice_input stack-mode on/off` - スタックモードの有効/無効
2. `voice_input start` - 録音開始（スタック保存）
3. `voice_input paste <number>` - スタック番号でペースト
4. `voice_input list-stacks` - スタック一覧表示
5. `voice_input clear-stacks` - 全スタッククリア

### 課題

- **多数のキーバインディングが必要**: 各コマンドを個別にランチャーアプリに設定する必要
- **効率性の問題**: 特に `paste <number>` コマンドでは複数の番号に対応した設定が必要
- **ワークフロー断続**: スタック一覧確認とペースト操作が分離している

### 解決後の簡素化

**現在**: 5つのコマンド × 複数の番号 = 多数のキーバインド設定
**提案後**: `voice_input shortcut-mode toggle` の1つのキーバインド設定のみ

## ショートカットキーモードの提案

### 設計コンセプト

デーモン側でグローバルキーボードフックを実装し、以下のワークフローを実現：

1. **統合されたスタック操作UI**: 一つのキーでスタック一覧表示 + 数字キーでダイレクトペースト
2. **モード切り替え**: ショートカットキーモードの有効/無効を単一キーで制御
3. **視覚的フィードバック**: 現在のモード状態とスタック情報をオーバーレイ表示

### 提案するキーバインディング

#### モード切り替え（CLI経由）

```bash
voice_input shortcut-mode toggle  # ショートカットキーモードのon/off切り替え
```

#### ショートカット操作（ショートカットキーモード有効時のみ）

**重要**: 以下のキーは ショートカットキーモード有効時のみ機能し、無効時は通常のキー入力として動作

- `cmd + R` : 録音開始/停止（トグル）
- `cmd + M` : スタックモード有効/無効（トグル）
- `cmd + S` : スタック一覧表示オーバーレイ
- `cmd + 1-9` : 対応する番号のスタックを直接ペースト
- `cmd + C` : 全スタッククリア

**設計方針**:

- **シンプル**: モード切り替えは全てCLI経由で統一
- **安全**: 誤操作でキーフックが残る心配なし
- **完結**: ショートカットモード内で録音・スタック操作が完結
- **一貫性**: 既存のstack-mode等と同じパターン

**キー上書きの制限**:

- macOSシステムレベルのショートカット（`Cmd+Tab`, `Cmd+Space`等）は上書き不可
- アプリケーションレベルでのキャプチャに制限あり
- 完全な上書きではなく、優先度に基づく処理となる

### 技術的実装アプローチ

#### アーキテクチャ変更

```
現在: [外部ランチャー] → [CLI] → [IPC] → [Daemon]
提案: [Global Key Hook] → [Daemon] → [Direct Action]
```

#### 実装候補技術

##### 1. Rust native approach

- **ライブラリ**: `rdev` または `device_query`
- **実装詳細**:
  ```rust
  // OSの低レベルキーボードAPIを直接呼び出し
  rdev::listen(move |event| {
      match event.event_type {
          EventType::KeyPress(key) => {
              if shortcut_mode_enabled && key == Key::KeyS {
                  show_stack_overlay();
              }
          }
      }
  });
  ```
- **仕組み**: OSの低レベルキーボードAPIを直接呼び出してグローバルキーイベントをキャプチャ
- **pros**: 単一バイナリ、最高性能、他プロセス不要
- **cons**: macOSアクセシビリティ権限必須、実装が複雑、権限エラー時の対応が困難

##### 2. AppleScript integration

- **実装**: AppleScript経由でのグローバルホットキー
- **pros**: macOS標準、比較的簡単
- **cons**: 制限が多い、パフォーマンス問題

##### 3. Hybrid approach (推奨)

- **組み合わせ**: Rustベースの軽量キーフック + 既存IPC
- **実装詳細**:

  ```rust
  // voice_input_hotkey バイナリ
  fn main() {
      setup_global_hooks(); // 基本的なキーフックのみ

      // 検出したキーを既存IPCで送信
      send_cmd(&IpcCmd::PasteStack { number: 1 });
  }
  ```

- **仕組み**: 最小限のキー検出機能 + 既存コマンドシステムの流用
- **pros**: 既存アーキテクチャを活用、段階的実装可能、フォールバック確保
- **cons**: 若干のオーバーヘッド

### 実装ファイル構成案

```
src/
├── hotkey/                      # 新規モジュール
│   ├── mod.rs
│   ├── key_handler.rs          # グローバルキーフック
│   ├── overlay_ui.rs           # スタック一覧オーバーレイ
│   └── shortcut_mode.rs        # ショートカットモード管理
├── bin/
│   └── voice_input_hotkey.rs   # 新規バイナリ
└── ...
```

### UIコンポーネント設計（最小限）

#### スタック一覧オーバーレイ（シンプル版）

```
┌─────────────────────────────────┐
│ [1] Hello, world!               │
│ [2] Meeting notes...            │
│ [3] Code snippet: fn...         │
├─────────────────────────────────┤
│ Press 1-3 to paste, ESC to exit │
└─────────────────────────────────┘
```

**設計方針**:

- スタック内容のみを表示（時刻、件数表示は省略）
- 最小限の操作ガイドのみ
- 軽量で高速な表示を優先

## 実現可能性評価

### 技術的実現可能性: ★★★☆☆ (中程度)

**課題:**

- macOSのアクセシビリティ権限管理
- グローバルキーフックの安定性
- 既存アーキテクチャとの統合

**解決策:**

- 段階的実装（最初はシンプルなキーフック）
- フォールバック機能（CLIコマンドは併用）
- 十分なエラーハンドリング

### ユーザビリティ向上効果: ★★★★★ (高)

**期待効果:**

- **操作数削減**: 5回のキー操作 → 2回
- **ワークフロー統合**: 一覧表示とペーストがシームレス
- **視覚的フィードバック**: 現在の状態が明確

### 開発コスト: ★★★☆☆ (中程度)

**新規開発が必要な機能:**

1. グローバルキーフック (2-3日)
2. オーバーレイUI (3-4日)
3. ショートカットモード管理 (1-2日)
4. 既存システムとの統合 (2-3日)
5. テストとデバッグ (3-5日)

**合計推定**: 11-17日

## 段階的実装計画

### Phase 1: Basic Hotkey Support

- グローバルキーフック基盤実装
- 基本的な録音開始/停止のショートカット
- IPC経由での既存コマンド呼び出し

### Phase 2: Stack Operations

- スタック一覧表示オーバーレイ
- 数字キーによる直接ペースト
- 視覚的フィードバック機能

### Phase 3: Advanced Features

- モード切り替えの統合
- カスタマイズ可能キーバインド
- パフォーマンス最適化

### Phase 4: Polish & Integration

- エラーハンドリング強化
- ドキュメント整備
- 既存CLIとの併用最適化

## リスク評価

### 高リスク

- **権限問題**: macOSアクセシビリティ権限の要求とUX影響
- **パフォーマンス**: グローバルキーフックによるシステム負荷

### 中リスク

- **キーコンフリクト**: 他アプリケーションとのキーバインド競合
- **安定性**: キーフック機能のクラッシュ耐性

### 低リスク

- **実装複雑度**: 既存アーキテクチャとの統合は十分可能

## 代替案検討

### 案1: 専用ランチャーアプリ連携

- Alfred/Raycast向けの専用プラグイン開発
- **pros**: 高い統合性、UX良好
- **cons**: 特定ツールへの依存

### 案2: メニューバー常駐アプリ

- メニューバーからのスタック操作UI
- **pros**: macOS標準UI、安定
- **cons**: マウス操作必要、効率性劣る

### 案3: Webベースインターフェース

- ローカルWebサーバーでの操作UI
- **pros**: 高いカスタマイズ性
- **cons**: 起動コスト、セキュリティ考慮

## 結論

ショートカットキーモードは **技術的に実現可能** であり、**ユーザビリティの大幅な向上** が期待できる。

**推奨アプローチ:**

- Hybrid approach（Rust + 既存IPC）
- 段階的実装による リスク軽減
- 既存CLIとの併用によるフォールバック確保

**次のステップ:**

1. Phase 1の技術検証（キーフック基盤）
2. macOSアクセシビリティ権限のUX設計
3. プロトタイプ実装とユーザビリティテスト

実装により、StackingModeの使用体験は劇的に改善され、voice_inputの付加価値を大幅に向上させる可能性が高い。
