# 音声入力コンテキスト精度向上アイデア

## 背景

現在の実装では、録音開始時の選択範囲をプロンプトに含めることで文字起こしの精度向上を図っています。
より豊かなコンテキストを提供することで、さらなる精度向上が期待できます。

## 現状の評価

**現在の実装**
- 録音開始時の選択テキストをWhisper APIのプロンプトとして使用
- 単一のコンテキスト情報のみを利用

## 提案されたアイデアの評価

### 1. 時間ベースでの過去入力の利用
**利点**
- 最近の文脈は関連性が高い
- 実装がシンプル

**課題**
- 最適な時間幅の判断が困難
- 無関係な情報も含まれる可能性

### 2. 時間＋アプリケーションベースでの分類
**利点**
- アプリケーション別に適切な文脈を保持
- より精度の高いコンテキスト提供

**課題**
- 実装の複雑性が増す
- メモリ使用量の増加

## 改善案

### 1. セッションベースコンテキスト管理

30分間の非アクティブ期間でセッションを区切り、関連性の高い文脈を維持します。

```rust
struct TranscriptionSession {
    entries: Vec<TranscriptionEntry>,
    last_activity: Instant,
    session_id: Uuid,
}

struct TranscriptionEntry {
    text: String,
    app_name: String,
    timestamp: SystemTime,
    confidence: f32,
    used_words: HashSet<String>,
}

impl TranscriptionSession {
    const SESSION_TIMEOUT: Duration = Duration::from_secs(30 * 60);
    
    fn is_active(&self) -> bool {
        self.last_activity.elapsed() < Self::SESSION_TIMEOUT
    }
    
    fn get_context(&self, limit: usize) -> String {
        // 最新のN件のエントリーから文脈を生成
        self.entries
            .iter()
            .rev()
            .take(limit)
            .map(|e| &e.text)
            .collect::<Vec<_>>()
            .join(" ")
    }
}
```

### 2. スマートコンテキスト選択（重み付けアルゴリズム）

関連性に基づいて動的にコンテキストを選択し、より適切な文脈を提供します。

```rust
struct ContextSelector {
    weight_time_decay: f32,     // 時間減衰係数
    weight_same_app: f32,       // 同一アプリ重み
    weight_text_similarity: f32, // テキスト類似度重み
}

impl ContextSelector {
    fn calculate_relevance_score(
        &self,
        entry: &TranscriptionEntry,
        current_app: &str,
        current_time: SystemTime,
    ) -> f32 {
        let mut score = 0.0;
        
        // 時間的近接性（指数関数的減衰）
        let time_diff = current_time.duration_since(entry.timestamp)
            .unwrap_or_default()
            .as_secs() as f32;
        score += (-time_diff / 3600.0).exp() * self.weight_time_decay;
        
        // 同一アプリケーション
        if entry.app_name == current_app {
            score += self.weight_same_app;
        }
        
        // TODO: テキスト類似度の計算
        
        score
    }
    
    fn select_context(
        &self,
        entries: &[TranscriptionEntry],
        current_app: &str,
        max_tokens: usize,
    ) -> String {
        let current_time = SystemTime::now();
        let mut scored_entries: Vec<_> = entries
            .iter()
            .map(|e| (
                self.calculate_relevance_score(e, current_app, current_time),
                e
            ))
            .collect();
        
        scored_entries.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap());
        
        // トークン数制限内で最も関連性の高いエントリーを選択
        let mut context = String::new();
        let mut token_count = 0;
        
        for (_, entry) in scored_entries {
            let entry_tokens = entry.text.split_whitespace().count();
            if token_count + entry_tokens > max_tokens {
                break;
            }
            context.push_str(&entry.text);
            context.push(' ');
            token_count += entry_tokens;
        }
        
        context.trim().to_string()
    }
}
```

### 3. 専門用語・固有名詞の自動学習

繰り返し使用される単語を自動的に検出し、辞書に追加します。

```rust
struct AdaptiveDictionary {
    term_frequency: HashMap<String, TermInfo>,
    auto_entries: Vec<WordEntry>,
    min_frequency: usize,
    min_confidence: f32,
}

struct TermInfo {
    count: usize,
    first_seen: SystemTime,
    contexts: Vec<String>,
}

impl AdaptiveDictionary {
    fn update_term_frequency(&mut self, text: &str) {
        // 固有名詞や専門用語の可能性が高い単語を抽出
        let words = extract_potential_terms(text);
        
        for word in words {
            self.term_frequency
                .entry(word.clone())
                .and_modify(|info| info.count += 1)
                .or_insert_with(|| TermInfo {
                    count: 1,
                    first_seen: SystemTime::now(),
                    contexts: vec![text.to_string()],
                });
        }
    }
    
    fn promote_to_dictionary(&mut self) {
        let candidates: Vec<_> = self.term_frequency
            .iter()
            .filter(|(_, info)| info.count >= self.min_frequency)
            .map(|(term, _)| term.clone())
            .collect();
        
        for term in candidates {
            // 既存の辞書にない場合のみ追加
            if !self.auto_entries.iter().any(|e| e.surface == term) {
                self.auto_entries.push(WordEntry {
                    surface: term.clone(),
                    replacement: term, // そのまま
                    status: EntryStatus::AutoGenerated,
                    created_at: SystemTime::now(),
                });
            }
        }
    }
}

fn extract_potential_terms(text: &str) -> Vec<String> {
    // カタカナ語、英数字混じり、大文字始まりなどを抽出
    text.split_whitespace()
        .filter(|word| {
            is_katakana(word) || 
            is_mixed_alphanumeric(word) ||
            is_capitalized(word)
        })
        .map(|s| s.to_string())
        .collect()
}
```

### 4. アプリケーション別コンテキストテンプレート

アプリケーションごとに最適化されたプロンプトテンプレートを提供します。

```rust
struct AppContextTemplate {
    templates: HashMap<String, ContextTemplate>,
}

struct ContextTemplate {
    app_name: String,
    base_prompt: String,
    vocabulary_hints: Vec<String>,
    style_hints: String,
}

impl AppContextTemplate {
    fn new() -> Self {
        let mut templates = HashMap::new();
        
        templates.insert("Slack".to_string(), ContextTemplate {
            app_name: "Slack".to_string(),
            base_prompt: "カジュアルなチャットメッセージ。".to_string(),
            vocabulary_hints: vec!["絵文字", "スレッド", "メンション", "チャンネル"],
            style_hints: "口語的、フレンドリー、絵文字使用可".to_string(),
        });
        
        templates.insert("Code".to_string(), ContextTemplate {
            app_name: "Code".to_string(),
            base_prompt: "プログラミングコード、コメント。".to_string(),
            vocabulary_hints: vec!["function", "variable", "class", "import"],
            style_hints: "技術用語、変数名はキャメルケース、スネークケース".to_string(),
        });
        
        templates.insert("Mail".to_string(), ContextTemplate {
            app_name: "Mail".to_string(),
            base_prompt: "ビジネスメール。".to_string(),
            vocabulary_hints: vec!["お世話になっております", "よろしくお願いします"],
            style_hints: "丁寧語、敬語、ビジネス文書".to_string(),
        });
        
        Self { templates }
    }
    
    fn get_prompt(&self, app_name: &str, base_context: &str) -> String {
        if let Some(template) = self.templates.get(app_name) {
            format!(
                "{} {} 文体: {} 関連用語: {:?}",
                template.base_prompt,
                base_context,
                template.style_hints,
                template.vocabulary_hints
            )
        } else {
            base_context.to_string()
        }
    }
}
```

### 5. マルチモーダルコンテキスト（将来的な拡張）

視覚的な情報も含めた、より豊富なコンテキストを提供します。

```rust
struct MultiModalContext {
    text_context: String,
    visual_context: Option<VisualContext>,
    cursor_context: Option<CursorContext>,
}

struct VisualContext {
    screenshot_ocr_text: String,
    ui_elements: Vec<UIElement>,
}

struct CursorContext {
    surrounding_text: String,
    position: (i32, i32),
    active_element_type: String,
}

impl MultiModalContext {
    async fn capture_full_context(&mut self) -> Result<(), Box<dyn Error>> {
        // カーソル周辺のテキストを取得
        self.cursor_context = Some(self.capture_cursor_context().await?);
        
        // 必要に応じて画面の一部をOCR
        if self.should_capture_visual() {
            self.visual_context = Some(self.capture_visual_context().await?);
        }
        
        Ok(())
    }
}
```

## 実装優先順位

1. **フェーズ1: セッションベース管理**
   - 実装が比較的簡単
   - 即座に効果が期待できる
   - 既存システムへの影響が小さい

2. **フェーズ2: スマートコンテキスト選択**
   - 中程度の実装難易度
   - 大幅な精度向上が期待できる

3. **フェーズ3: 専門用語の自動学習**
   - 長期的な精度向上
   - ユーザー体験の継続的改善

4. **フェーズ4: アプリケーション別テンプレート**
   - 特定用途での精度向上
   - カスタマイズ性の向上

5. **フェーズ5: マルチモーダルコンテキスト**
   - 最も複雑な実装
   - 革新的な機能拡張

## 期待される効果

- **精度向上**: 15-30%の認識精度向上
- **ユーザビリティ**: 専門用語の自動学習により手動辞書登録の手間を削減
- **適応性**: 使用パターンに応じた自動最適化
- **拡張性**: 将来的な機能追加の基盤構築

## 技術的考慮事項

- **メモリ管理**: セッション情報の適切な管理とクリーンアップ
- **プライバシー**: センシティブな情報の適切な処理
- **パフォーマンス**: コンテキスト生成のオーバーヘッドを最小限に
- **互換性**: 既存のAPIとの後方互換性の維持